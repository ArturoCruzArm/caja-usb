<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caja USB XV Naomi - Producciones Foro 7</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%230a0a0f'/%3E%3Crect x='4' y='10' width='24' height='16' rx='3' fill='%235a3a1a' stroke='%23d4af37' stroke-width='0.8'/%3E%3Crect x='3' y='8' width='26' height='4' rx='2' fill='%234a2a10' stroke='%23d4af37' stroke-width='0.8'/%3E%3Crect x='10' y='16' width='12' height='5' rx='1.5' fill='%231a1008'/%3E%3Crect x='12' y='17' width='8' height='3' rx='0.8' fill='%23888898'/%3E%3C/svg%3E">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
            user-select: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #title-overlay {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(212,175,55,0.6); font-size: 11px; letter-spacing: 4px;
            font-family: monospace; text-transform: uppercase;
            pointer-events: none; text-align: center;
        }
        #title-overlay .sub {
            display: block; font-size: 9px; color: rgba(255,255,255,0.3);
            letter-spacing: 2px; margin-top: 4px;
        }
        #toggle-btn {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(212,175,55,0.1); border: 1px solid rgba(212,175,55,0.3);
            color: #d4af37; padding: 10px 28px; border-radius: 8px;
            font-family: monospace; font-size: 12px; letter-spacing: 3px;
            text-transform: uppercase; cursor: pointer; transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        #toggle-btn:hover { background: rgba(212,175,55,0.2); border-color: rgba(212,175,55,0.5); }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="title-overlay">
        Caja USB Premium
        <span class="sub">Producciones Foro 7</span>
    </div>
    <button id="toggle-btn">Abrir Caja</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        'use strict';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a0f, 0.035);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.85;

        // --- DIMENSIONS ---
        const BW = 3.5;   // box width
        const BD = 3.5;   // box depth
        const BH = 1.5;   // box height (walls)
        const LH = 0.2;   // lid height
        const WALL = 0.12;
        const FOAM_H = 0.8; // foam height

        // --- TEXTURES ---
        function createWoodTexture(w, h, baseColor) {
            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = baseColor || '#5a3a1a';
            ctx.fillRect(0, 0, w, h);

            for (let i = 0; i < 80; i++) {
                const y = Math.random() * h;
                ctx.strokeStyle = `rgba(${60+Math.random()*40},${30+Math.random()*25},${10+Math.random()*15},${0.1+Math.random()*0.12})`;
                ctx.lineWidth = Math.random() * 2 + 0.5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                for (let x = 0; x < w; x += 8) {
                    ctx.lineTo(x, y + Math.sin(x * 0.015 + i) * 3);
                }
                ctx.stroke();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createFoamTexture(w, h) {
            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1a1520';
            ctx.fillRect(0, 0, w, h);

            // Soft velvet-like noise
            for (let i = 0; i < 3000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                ctx.fillStyle = `rgba(${30+Math.random()*20},${20+Math.random()*15},${35+Math.random()*20},0.3)`;
                ctx.fillRect(x, y, 1, 1);
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createLidEngravingTexture(w, h) {
            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, w, h);

            ctx.fillStyle = 'rgba(212, 175, 55, 0.5)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.font = 'bold 42px Georgia, serif';
            ctx.fillText('XV Naomi', w/2, h * 0.4);

            ctx.font = '16px monospace';
            ctx.fillStyle = 'rgba(212, 175, 55, 0.35)';
            ctx.fillText('PRODUCCIONES FORO 7', w/2, h * 0.6);

            // Decorative border
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.2)';
            ctx.lineWidth = 1.5;
            const pad = 20;
            ctx.strokeRect(pad, pad, w - pad*2, h - pad*2);

            return new THREE.CanvasTexture(canvas);
        }

        const woodTex = createWoodTexture(512, 512, '#5a3a1a');
        const woodDarkTex = createWoodTexture(512, 512, '#3a2510');
        const foamTex = createFoamTexture(256, 256);
        const lidEngraveTex = createLidEngravingTexture(512, 512);

        // --- MATERIALS ---
        const woodMat = new THREE.MeshPhongMaterial({ map: woodTex, specular: 0x332211, shininess: 25 });
        const woodDarkMat = new THREE.MeshPhongMaterial({ map: woodDarkTex, specular: 0x221100, shininess: 15 });
        const foamMat = new THREE.MeshPhongMaterial({ map: foamTex, specular: 0x000000, shininess: 5 });
        const goldMat = new THREE.MeshPhongMaterial({ color: 0xd4af37, specular: 0xffffff, shininess: 60, emissive: 0xd4af37, emissiveIntensity: 0.05 });
        const metalMat = new THREE.MeshPhongMaterial({ color: 0xa0a0b0, specular: 0xffffff, shininess: 100 });
        const velvetMat = new THREE.MeshPhongMaterial({ color: 0x1a1520, specular: 0x000000, shininess: 5 });

        // --- BOX GROUP ---
        const boxGroup = new THREE.Group();
        const lidGroup = new THREE.Group();

        // === BOX BASE ===
        // Floor
        const floor = new THREE.Mesh(new THREE.BoxGeometry(BW, WALL, BD), woodMat);
        floor.position.y = -BH / 2;
        boxGroup.add(floor);

        // Walls
        const wallDefs = [
            { geo: [BW, BH, WALL], pos: [0, 0, BD/2] },
            { geo: [BW, BH, WALL], pos: [0, 0, -BD/2] },
            { geo: [WALL, BH, BD], pos: [-BW/2, 0, 0] },
            { geo: [WALL, BH, BD], pos: [BW/2, 0, 0] },
        ];
        wallDefs.forEach(w => {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(...w.geo), woodMat);
            wall.position.set(...w.pos);
            boxGroup.add(wall);
        });

        // Interior velvet floor
        const interiorFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(BW - WALL*2, BD - WALL*2),
            velvetMat
        );
        interiorFloor.rotation.x = -Math.PI / 2;
        interiorFloor.position.y = -BH / 2 + WALL + 0.005;
        boxGroup.add(interiorFloor);

        // === FOAM INSERT ===
        const foamGroup = new THREE.Group();
        foamGroup.position.y = -BH / 2 + WALL + FOAM_H / 2;

        // Main foam block
        const foamBlock = new THREE.Mesh(
            new THREE.BoxGeometry(BW - WALL * 4, FOAM_H, BD - WALL * 4),
            foamMat
        );
        foamGroup.add(foamBlock);

        // USB-shaped cutout (dark indent)
        const cutoutW = 1.4, cutoutH = 0.3, cutoutD = 0.55;
        const cutoutMat = new THREE.MeshPhongMaterial({ color: 0x0a0810, specular: 0x000000 });
        const cutout = new THREE.Mesh(
            new THREE.BoxGeometry(cutoutW, cutoutH, cutoutD),
            cutoutMat
        );
        cutout.position.y = FOAM_H / 2 - cutoutH / 2 + 0.01;
        foamGroup.add(cutout);

        // Mini USB inside cutout
        const miniUsbBody = new THREE.Mesh(
            new THREE.BoxGeometry(1.0, 0.2, 0.35),
            new THREE.MeshPhongMaterial({ color: 0x5a3a1a, specular: 0x332211, shininess: 20 })
        );
        miniUsbBody.position.y = FOAM_H / 2 - cutoutH / 2 + 0.12;
        foamGroup.add(miniUsbBody);

        // Mini USB connector
        const miniConn = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.12, 0.2),
            metalMat
        );
        miniConn.position.set(0.65, FOAM_H / 2 - cutoutH / 2 + 0.12, 0);
        foamGroup.add(miniConn);

        // Mini USB gold accent
        const miniGold = new THREE.Mesh(
            new THREE.PlaneGeometry(0.4, 0.18),
            new THREE.MeshPhongMaterial({ color: 0xd4af37, transparent: true, opacity: 0.5 })
        );
        miniGold.rotation.x = -Math.PI / 2;
        miniGold.position.set(-0.1, FOAM_H / 2 - cutoutH / 2 + 0.22, 0);
        foamGroup.add(miniGold);

        boxGroup.add(foamGroup);

        // === LID ===
        // Lid body
        const lidBody = new THREE.Mesh(
            new THREE.BoxGeometry(BW + 0.08, LH, BD + 0.08),
            woodDarkMat
        );
        lidGroup.add(lidBody);

        // Lid engraving on top
        const lidEngrave = new THREE.Mesh(
            new THREE.PlaneGeometry(BW * 0.7, BD * 0.7),
            new THREE.MeshPhongMaterial({ map: lidEngraveTex, transparent: true, depthWrite: false })
        );
        lidEngrave.rotation.x = -Math.PI / 2;
        lidEngrave.position.y = LH / 2 + 0.005;
        lidGroup.add(lidEngrave);

        // Gold border on lid
        const borderGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(BW + 0.06, LH - 0.02, BD + 0.06));
        const borderMat = new THREE.LineBasicMaterial({ color: 0xd4af37, transparent: true, opacity: 0.4 });
        lidGroup.add(new THREE.LineSegments(borderGeo, borderMat));

        // Magnetic clasp dot
        const claspGeo = new THREE.CylinderGeometry(0.06, 0.06, LH + 0.02, 12);
        const clasp = new THREE.Mesh(claspGeo, goldMat);
        clasp.position.set(0, 0, BD / 2 + 0.04);
        lidGroup.add(clasp);

        lidGroup.position.set(0, BH / 2 + LH / 2, 0);
        boxGroup.add(lidGroup);
        scene.add(boxGroup);

        // --- LID ANIMATION ---
        let boxOpened = false;
        let lidLift = 0, targetLidLift = 0;
        let isTransitioning = false;

        function toggleBox() {
            if (isTransitioning) return;
            boxOpened = !boxOpened;
            targetLidLift = boxOpened ? 3.0 : 0;
            isTransitioning = true;
            document.getElementById('toggle-btn').textContent = boxOpened ? 'Cerrar Caja' : 'Abrir Caja';
            setTimeout(() => { isTransitioning = false; }, 800);
        }

        document.getElementById('toggle-btn').addEventListener('click', toggleBox);

        // --- LIGHTS ---
        const ambLight = new THREE.AmbientLight(0x404050, 0.4);
        scene.add(ambLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
        mainLight.position.set(3, 5, 4);
        scene.add(mainLight);

        const warmLight = new THREE.PointLight(0xd4af37, 0.25, 15);
        warmLight.position.set(-3, 3, 2);
        scene.add(warmLight);

        const coolLight = new THREE.PointLight(0x4488cc, 0.2, 15);
        coolLight.position.set(2, -1, -3);
        scene.add(coolLight);

        // --- CAMERA ---
        const camDist = 6;
        camera.position.set(0, camDist * 0.7, camDist * 0.7);
        camera.lookAt(0, 0, 0);

        // --- INTERACTION ---
        let rotX = -0.3, rotY = -0.4;
        let targetRotX = rotX, targetRotY = rotY;
        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;

        function onPointerDown(x, y) { isDragging = true; dragStartX = x; dragStartY = y; }
        function onPointerMove(x, y) {
            if (!isDragging) return;
            targetRotY += (x - dragStartX) * 0.006;
            targetRotX += (y - dragStartY) * 0.006;
            targetRotX = Math.max(-1.4, Math.min(0.3, targetRotX));
            dragStartX = x; dragStartY = y;
        }
        function onPointerUp() { isDragging = false; }

        document.addEventListener('mousedown', e => onPointerDown(e.clientX, e.clientY));
        document.addEventListener('mousemove', e => onPointerMove(e.clientX, e.clientY));
        document.addEventListener('mouseup', onPointerUp);
        document.addEventListener('touchstart', e => { e.preventDefault(); onPointerDown(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        document.addEventListener('touchmove', e => { e.preventDefault(); onPointerMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        document.addEventListener('touchend', onPointerUp);

        document.addEventListener('wheel', e => {
            e.preventDefault();
            camera.position.multiplyScalar(e.deltaY > 0 ? 1.05 : 0.95);
            const d = camera.position.length();
            if (d < 3) camera.position.setLength(3);
            if (d > 12) camera.position.setLength(12);
        }, { passive: false });

        // --- ANIMATE ---
        function animate() {
            requestAnimationFrame(animate);

            rotX += (targetRotX - rotX) * 0.08;
            rotY += (targetRotY - rotY) * 0.08;
            boxGroup.rotation.x = rotX;
            boxGroup.rotation.y = rotY;

            // Lid lift
            lidLift += (targetLidLift - lidLift) * 0.04;
            lidGroup.position.y = BH / 2 + LH / 2 + lidLift;

            // Gentle float
            boxGroup.position.y = Math.sin(Date.now() * 0.001) * 0.04;

            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }
        animate();

        // --- RESIZE ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    })();
    </script>
</body>
</html>
